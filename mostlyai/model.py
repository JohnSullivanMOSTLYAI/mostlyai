# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/mostly-ai/mostly-app-v2/llb2/mstar/public-api/public-api.yaml?token=GHSAT0AAAAAABI33CIJW7ZOOLBVUZZFZS6QZM5ULBQ
#   timestamp: 2024-01-09T18:47:26+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Dict, List, Optional
from uuid import UUID

from pydantic import Field, RootModel

from mostlyai.base import CustomBaseModel


class BaseResource(CustomBaseModel):
    id: Annotated[
        Optional[UUID], Field(description="The unique identifier of the entity")
    ] = None
    name: Annotated[Optional[str], Field(description="The name of the entity")] = None
    uri: Annotated[
        Optional[str],
        Field(
            description="The API service endpoint of the entity",
            example="/generators/94c77249-42bf-443a-8e17-6e18a19d60b8",
        ),
    ] = None


class Metadata(CustomBaseModel):
    created_at: Annotated[
        Optional[str], Field(alias="createdAt", example="2023‐09‐07T18:40:39Z")
    ] = None
    owner_id: Annotated[
        Optional[str],
        Field(
            alias="ownerId",
            description="The unique identifier of the owner of the entity",
        ),
    ] = None
    owner_name: Annotated[
        Optional[str],
        Field(alias="ownerName", description="The name of the owner of the entity"),
    ] = None


class PaginatedTotalCount(RootModel[int]):
    root: Annotated[
        int, Field(description="The total number of entities within the list")
    ]


class ConnectorAccessType(Enum):
    source = "SOURCE"
    destination = "DESTINATION"


class ConnectorType(Enum):
    mysql = "MYSQL"
    postgres = "POSTGRES"
    mssql = "MSSQL"
    oracle = "ORACLE"
    mariadb = "MARIADB"
    snowflake = "SNOWFLAKE"
    bigquery = "BIGQUERY"
    databricks = "DATABRICKS"
    azure_storage = "AZURE_STORAGE"
    google_cloud_storage = "GOOGLE_CLOUD_STORAGE"
    s3_storage = "S3_STORAGE"
    local_storage = "LOCAL_STORAGE"
    http = "HTTP"
    file_upload = "FILE_UPLOAD"


class ConnectorTestConnection(RootModel[bool]):
    root: Annotated[
        bool,
        Field(
            description="If true, the connection will be tested before saving. In case of error, the connector will not be saved.\nIf false, the connection will not be tested.\n"
        ),
    ]


class ConnectorListItem(CustomBaseModel):
    id: Annotated[UUID, Field(description="The unique identifier of a connector")]
    name: Annotated[str, Field(description="The name of a connector")]
    type: ConnectorType
    access_type: Annotated[ConnectorAccessType, Field(alias="accessType")]
    metadata: Metadata


class Connector(CustomBaseModel):
    id: Annotated[UUID, Field(description="The unique identifier of a connector")]
    name: Annotated[str, Field(description="The name of a connector")]
    type: ConnectorType
    access_type: Annotated[ConnectorAccessType, Field(alias="accessType")]
    config: Optional[Dict[str, Any]] = None
    secrets: Optional[Dict[str, str]] = None
    ssl: Optional[Dict[str, str]] = None
    metadata: Optional[Metadata] = None
    table_id: Annotated[
        Optional[UUID],
        Field(
            alias="tableId",
            description="Optional. ID of a source table or a synthetic table, that this connector belongs to.\nIf not set, then this connector is managed independently of any generator or synthetic dataset.\n",
        ),
    ] = None

    def locations(self, prefix: str = "") -> list:
        if self.client and hasattr(self.client, "locations"):
            return self.client.locations(connector_id=self.id, prefix=prefix)


class GeneratorUsage(CustomBaseModel):
    total_datapoints: Annotated[
        Optional[int],
        Field(
            alias="totalDatapoints",
            description="The total number of datapoints generated by this generator.",
        ),
    ] = None


class SourceColumnModelEncodingType(Enum):
    """
    The encoding type used for model training and data generation.
    This property is only relevant if generation method is AI_MODEL.
    - CATEGORICAL: Model samples from existing (non-rare) categories.
    - NUMERIC_AUTO: Model chooses among 3 numeric encoding types based on the values.
    - NUMERIC_DISCRETE: Model samples from existing discrete numerical values.
    - NUMERIC_BINNED: Model samples from binned buckets, to then sample randomly within a bucket.
    - NUMERIC_DIGIT: Model samples each digit of a numerical value.
    - CHARACTER: Model samples each character of a string value.
    - DATETIME: Model samples each part of a datetime value.
    - DATETIME_RELATIVE: Model samples the relative difference between datetimes within a sequence.
    - LAT_LONG: Model samples a latitude-longitude column. The format is "latitude,longitude".
    - TEXT_MODEL: Model will train a distinct TEXT model for this column.

    """

    categorical = "CATEGORICAL"
    numeric_auto = "NUMERIC_AUTO"
    numeric_discrete = "NUMERIC_DISCRETE"
    numeric_binned = "NUMERIC_BINNED"
    numeric_digit = "NUMERIC_DIGIT"
    character = "CHARACTER"
    datetime = "DATETIME"
    datetime_relative = "DATETIME_RELATIVE"
    lat_long = "LAT_LONG"
    text_model = "TEXT_MODEL"


class SourceColumn(CustomBaseModel):
    id: Annotated[UUID, Field(description="The unique identifier of a source column")]
    name: Annotated[str, Field(description="The name of a source column")]
    included: Annotated[
        bool,
        Field(
            description="If true, the column will be included in the training.\nIf false, the column will be excluded from the training.\n"
        ),
    ]
    model_encoding_type: Annotated[
        SourceColumnModelEncodingType, Field(alias="modelEncodingType")
    ]


class SourceForeignKey(CustomBaseModel):
    id: Annotated[UUID, Field(description="The unique identifier of a foreign key")]
    column: Annotated[
        Optional[str], Field(description="The column name of a foreign key.")
    ] = None
    referenced_table: Annotated[
        str,
        Field(
            alias="referencedTable",
            description="The table name of the referenced table. That table must have a primary key already defined.",
        ),
    ]
    is_context: Annotated[
        bool,
        Field(
            alias="isContext",
            description="If true, then the foreign key will be considered as a context relation.\nNote, that only one foreign key relation per table can be a context relation.\n",
        ),
    ]


class ModelSize(Enum):
    """
    The size of the model, with the default being M(edium).
    Choose S(mall) for faster training, or L(arge) for better results for large dataset.
    Note, that larger model sizes will require more memory and more compute.

    """

    s = "S"
    m = "M"
    l = "L"


class RareCategoryReplacementMethod(Enum):
    """
    Specifies, if the rare categories for categoricals will be replaced by a constant
    _RARE_ or by a sample from non-rare categories.

    """

    constant = "CONSTANT"
    sample = "SAMPLE"


class ModelConfiguration(CustomBaseModel):
    sample_fraction: Annotated[
        Optional[float],
        Field(
            alias="sampleFraction",
            description="The fraction of samples to consider for training.\nIf not provided, then all available samples will be taken.\nCannot be used with maxSampleSize.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = 1.0
    max_sample_size: Annotated[
        Optional[int],
        Field(
            alias="maxSampleSize",
            description="The maximum number of samples to consider for training.\nIf not provided, then all available samples will be taken. \nCannot be used with sampleFraction.\n",
        ),
    ] = None
    batch_size: Annotated[
        Optional[int],
        Field(
            alias="batchSize",
            description="The batch size used for training the model.\nIf not provided, batchSize will be chosen automatically.\n",
        ),
    ] = None
    model_size: Annotated[
        ModelSize,
        Field(
            alias="modelSize",
            description="The size of the model, with the default being M(edium).\nChoose S(mall) for faster training, or L(arge) for better results for large dataset.\nNote, that larger model sizes will require more memory and more compute.\n",
        ),
    ]
    max_epochs: Annotated[
        Optional[int],
        Field(
            alias="maxEpochs",
            description="The maximum number of epochs to train the model. If not provided, then training \nwill continue until validation loss starts to increase again.\n",
        ),
    ] = 100
    max_sequence_length: Annotated[
        Optional[int],
        Field(
            alias="maxSequenceLength",
            description="The maximum sequence length to consider for training. \nIf provided, then a continuous sub-sequence of up to this length will be sampled. \nIf not provided, then the complete sequences, from start to end, will be taken.\n",
        ),
    ] = 100
    enable_flexible_generation: Annotated[
        bool,
        Field(
            alias="enableFlexibleGeneration",
            description="If true, then the trained generator can be used for rebalancing and imputation.\n",
        ),
    ]
    value_protection: Annotated[
        bool,
        Field(
            alias="valueProtection",
            description="Defines if Rare Category, Extreme value, or Sequence length protection will be applied.\n",
        ),
    ]
    rare_category_replacement_method: Annotated[
        RareCategoryReplacementMethod,
        Field(
            alias="rareCategoryReplacementMethod",
            description="Specifies, if the rare categories for categoricals will be replaced by a constant \n_RARE_ or by a sample from non-rare categories.\n",
        ),
    ]


class Accuracy(CustomBaseModel):
    overall: Annotated[
        Optional[float],
        Field(description="The overall accuracy of the model.", ge=0.0, le=1.0),
    ] = None
    univariate: Annotated[
        Optional[float],
        Field(description="The univariate accuracy of the model.", ge=0.0, le=1.0),
    ] = None
    bivariate: Annotated[
        Optional[float],
        Field(description="The bivariate accuracy of the model.", ge=0.0, le=1.0),
    ] = None
    coherence: Annotated[
        Optional[float],
        Field(
            description="The coherence accuracy of the model, in case of sequential data.",
            ge=0.0,
            le=1.0,
        ),
    ] = None
    overall_max: Annotated[
        Optional[float],
        Field(
            description="The overall accuracy for an actual holdout dataset.\nThis serves as a reference for the overall accuracy of the trained generator.\n",
            ge=0.0,
            le=1.0,
        ),
    ] = None


class Privacy(CustomBaseModel):
    dcr_original: Annotated[
        Optional[float],
        Field(description="The average DCR between the original records."),
    ] = None
    dcr_synthetic: Annotated[
        Optional[float],
        Field(
            description="The average DCR between the synthetic and the original records."
        ),
    ] = None


class ModelQAReport(CustomBaseModel):
    accuracy: Optional[Accuracy] = None
    privacy: Optional[Privacy] = None


class Model(CustomBaseModel):
    id: str
    configuration: ModelConfiguration
    qa: Optional[ModelQAReport] = None
    sample_size: Annotated[
        Optional[int],
        Field(
            alias="sampleSize",
            description="The actual number of samples used for training.",
        ),
    ] = None


class ProgressValue(CustomBaseModel):
    value: Optional[int] = None
    max: Optional[int] = None


class ProgressStatus(Enum):
    """
    The status of a job.
    NEW: The job is being configured, and has not started yet
    ON_HOLD: The job has been started, but is kept on hold
    QUEUED: The job has been started, and is awaiting for resources to execute
    IN_PROGRESS: The job is currently running
    DONE: The job has finished successfully
    FAILED: The job has failed
    CANCELED: The job has been canceled

    """

    new = "NEW"
    on_hold = "ON_HOLD"
    queued = "QUEUED"
    in_progress = "IN_PROGRESS"
    done = "DONE"
    failed = "FAILED"
    canceled = "CANCELED"


class SyntheticDatasetUsage(CustomBaseModel):
    total_datapoints: Annotated[
        Optional[int],
        Field(
            alias="totalDatapoints",
            description="The number of datapoints in the synthetic dataset",
        ),
    ] = None
    total_credits: Annotated[
        Optional[int],
        Field(
            alias="totalCredits",
            description="The number of credits used for the synthetic dataset",
        ),
    ] = None


class SyntheticDatasetListItem(CustomBaseModel):
    id: Annotated[
        UUID, Field(description="The unique identifier of a synthetic dataset")
    ]
    generator: Optional[BaseResource] = None
    metadata: Metadata
    name: Annotated[str, Field(description="The name of a synthetic dataset")]
    description: Annotated[
        Optional[str], Field(description="The description of a synthetic dataset")
    ] = None
    generation_status: Annotated[ProgressStatus, Field(alias="generationStatus")]
    usage: Optional[SyntheticDatasetUsage] = None


class Rebalancing(CustomBaseModel):
    """
    Configure rebalancing of the table.
    Only applicable for categorical columns of a subject table.

    """

    column_name: Annotated[
        Optional[UUID],
        Field(
            alias="columnName",
            description="The name of the column to be rebalanced.\nThat column must be of modelEncodingType CATEGORICAL.\n",
        ),
    ] = None
    probabilities: Annotated[
        Optional[Dict[str, str]],
        Field(
            description="The target distribution of samples values. \nThe keys are the categorical values, and the values are the probabilities.\n",
            example=[{"US": 0.8}, {"male": 0.5, "female": 0.5}],
        ),
    ] = None


class SyntheticTableConfiguration(CustomBaseModel):
    sample_size: Annotated[
        Optional[int],
        Field(
            alias="sampleSize",
            description="Number of generated samples. Only applicable for subject tables.\nCannot be used with sampleFraction or seedConnectorId.\n",
        ),
    ] = None
    sample_fraction: Annotated[
        Optional[float],
        Field(
            alias="sampleFraction",
            description="Fraction of source table total rows. Only applicable for subject tables.\nCannot be used with sampleSize or seedConnectorId.\n",
            ge=0.0,
        ),
    ] = 1.0
    sample_seed_connector_id: Annotated[
        Optional[UUID],
        Field(
            alias="sampleSeedConnectorId",
            description="The connector id of the seed data for conditional generation. \nOnly applicable for subject tables.\nCannot be used with sampleSize or sampleFraction.\n",
        ),
    ] = None
    sampling_temperature: Annotated[
        Optional[float],
        Field(
            alias="samplingTemperature",
            description="temperature for sampling",
            ge=0.0,
            le=10.0,
        ),
    ] = 1.0
    sampling_top_p: Annotated[
        Optional[float],
        Field(alias="samplingTopP", description="topP for sampling", ge=0.0, le=1.0),
    ] = 1.0
    rebalancing: Annotated[
        Optional[Rebalancing],
        Field(
            description="Configure rebalancing of the table.\nOnly applicable for categorical columns of a subject table.\n"
        ),
    ] = None
    imputation: Annotated[
        Optional[List[str]],
        Field(
            description="Specify a list of column names that are to be imputed.\nImputed columns will suppress the sampling of NULL values.\n"
        ),
    ] = None


class SyntheticColumnModelEncodingType(Enum):
    """
    The encoding type used for model training and data generation.
    This property is only relevant if generation method is AI_MODEL.
    - CATEGORICAL: Model samples from existing (non-rare) categories.
    - NUMERIC_AUTO: Model chooses among 3 numeric encoding types based on the values.
    - NUMERIC_DISCRETE: Model samples from existing discrete numerical values.
    - NUMERIC_BINNED: Model samples from binned buckets, to then sample randomly within a bucket.
    - NUMERIC_DIGIT: Model samples each digit of a numerical value.
    - CHARACTER: Model samples each character of a string value.
    - DATETIME: Model samples each part of a datetime value.
    - DATETIME_RELATIVE: Model samples the relative difference between datetimes within a sequence.
    - LAT_LONG: Model samples a latitude-longitude column. The format is "latitude,longitude".
    - TEXT_MODEL: Model will train a distinct TEXT model for this column.

    """

    categorical = "CATEGORICAL"
    numeric_auto = "NUMERIC_AUTO"
    numeric_discrete = "NUMERIC_DISCRETE"
    numeric_binned = "NUMERIC_BINNED"
    numeric_digit = "NUMERIC_DIGIT"
    character = "CHARACTER"
    datetime = "DATETIME"
    datetime_relative = "DATETIME_RELATIVE"
    lat_long = "LAT_LONG"
    text_model = "TEXT_MODEL"


class SyntheticColumn(CustomBaseModel):
    id: Annotated[
        Optional[UUID], Field(description="The unique identifier of a synthetic column")
    ] = None
    name: Annotated[
        Optional[str], Field(description="The name of a synthetic column")
    ] = None
    generator_column: Annotated[
        Optional[BaseResource], Field(alias="generatorColumn")
    ] = None
    model_encoding_type: Annotated[
        Optional[SyntheticColumnModelEncodingType], Field(alias="modelEncodingType")
    ] = None


class SyntheticForeignKey(CustomBaseModel):
    id: Annotated[UUID, Field(description="The unique identifier of a foreign key")]
    column: Annotated[
        Optional[str], Field(description="The column name of a foreign key.")
    ] = None
    referenced_table: Annotated[
        str,
        Field(
            alias="referencedTable",
            description="The table name of the referenced table.",
        ),
    ]
    is_context: Annotated[
        bool,
        Field(
            alias="isContext",
            description="If true, then the foreign key will be considered as a context relation.",
        ),
    ]


class SyntheticDatasetDelivery(CustomBaseModel):
    overwrite_tables: Annotated[
        Optional[bool],
        Field(
            alias="overwriteTables",
            description="If true, tables in the destination will be overwritten.\nIf false, any tables exist, the delivery will fail.\n",
        ),
    ] = None
    destination_connector: Annotated[
        Optional[BaseResource], Field(alias="destinationConnector")
    ] = None
    location: Annotated[
        Optional[str], Field(description="The location for the destination connector.")
    ] = None


class GeneratorListItem(CustomBaseModel):
    id: Annotated[UUID, Field(description="The unique identifier of a generator")]
    name: Annotated[str, Field(description="The name of a generator")]
    description: Annotated[
        Optional[str], Field(description="The description of a generator")
    ] = None
    training_status: Annotated[ProgressStatus, Field(alias="trainingStatus")]
    metadata: Metadata
    accuracy: Annotated[
        Optional[float],
        Field(
            description="The overall accuracy of the trained generator.\nThis is the average of the overall accuracy scores of all trained models.\n"
        ),
    ] = None
    usage: Optional[GeneratorUsage] = None


class SourceTable(CustomBaseModel):
    id: Annotated[UUID, Field(description="The unique identifier of a source table")]
    source_connector: Annotated[
        Optional[BaseResource], Field(alias="sourceConnector")
    ] = None
    location: Annotated[
        str,
        Field(
            description="The location of a source table. Together with the source connector it uniquely\nidentifies a source, and samples data from there.\n"
        ),
    ]
    name: Annotated[str, Field(description="The name of a source table")]
    primary_key: Annotated[
        Optional[str],
        Field(alias="primaryKey", description="The column name of the primary key"),
    ] = None
    columns: Annotated[
        List[SourceColumn], Field(description="The columns of this generator table.")
    ]
    foreign_keys: Annotated[
        Optional[List[SourceForeignKey]],
        Field(alias="foreignKeys", description="The foreign keys of a table."),
    ] = None
    model: Model
    text_model: Annotated[Optional[Model], Field(alias="textModel")] = None
    total_rows: Annotated[
        Optional[int],
        Field(
            alias="totalRows",
            description="The total number of rows in the source table while fetching data for training.\n",
        ),
    ] = None

    def model_qa_report(self) -> "ModelQAReport":
        if self.client and hasattr(self.client, "model_qa_report"):
            return self.client.model_qa_report(
                generator_id=self.extra_key_values["generator_id"], table_id=self.id
            )

    def model_samples(self, **kwargs):
        if self.client and hasattr(self.client, "model_samples"):
            return self.client.model_qa_report(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                **kwargs,
            )

    def get_column(self, column_id: str):
        if self.client and hasattr(self.client, "get_column"):
            return self.client.get_column(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                column_id=column_id,
            )

    def create_foreign_key(self, **kwargs):
        if self.client and hasattr(self.client, "create_foreign_key"):
            return self.client.create_foreign_key(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                **kwargs,
            )

    def update_foreign_key(self, **kwargs):
        if self.client and hasattr(self.client, "update_foreign_key"):
            return self.client.update_foreign_key(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                **kwargs,
            )

    def delete_foreign_key(self, **kwargs):
        if self.client and hasattr(self.client, "delete_foreign_key"):
            return self.client.delete_foreign_key(
                generator_id=self.extra_key_values["generator_id"],
                table_id=self.id,
                **kwargs,
            )


class ProgressStep(CustomBaseModel):
    id: Optional[str] = None
    table_name: Annotated[
        Optional[str],
        Field(
            alias="tableName",
            description="The name of the table that this step is associated with. Optional.",
        ),
    ] = None
    model_type: Annotated[
        Optional[str],
        Field(
            alias="modelType",
            description="The type of the model that this step is associated with. Optional.",
        ),
    ] = None
    step_code: Annotated[Optional[str], Field(alias="stepCode")] = None
    iteration: Optional[str] = None
    iteration_name: Annotated[Optional[str], Field(alias="iterationName")] = None
    duration: Annotated[Optional[int], Field(description="duration in seconds")] = None
    messages: Optional[List[str]] = None
    progress: Optional[ProgressValue] = None
    status: Optional[ProgressStatus] = None


class SyntheticTable(CustomBaseModel):
    id: Annotated[
        Optional[UUID], Field(description="The unique identifier of a synthetic table")
    ] = None
    name: Annotated[
        Optional[str], Field(description="The name of a synthetic table")
    ] = None
    primary_key: Annotated[
        Optional[str],
        Field(alias="primaryKey", description="The column name of the primary key"),
    ] = None
    generator_table: Annotated[
        Optional[BaseResource], Field(alias="generatorTable")
    ] = None
    configuration: Optional[SyntheticTableConfiguration] = None
    columns: Annotated[
        Optional[List[SyntheticColumn]],
        Field(description="The columns of this synthetic table."),
    ] = None
    foreign_keys: Annotated[
        Optional[List[SyntheticForeignKey]],
        Field(alias="foreignKeys", description="The foreign keys of a table."),
    ] = None


class Generator(CustomBaseModel):
    id: Annotated[UUID, Field(description="The unique identifier of a generator")]
    name: Annotated[str, Field(description="The name of a generator")]
    description: Annotated[
        Optional[str], Field(description="The description of a generator")
    ] = None
    training_status: Annotated[ProgressStatus, Field(alias="trainingStatus")]
    metadata: Metadata
    accuracy: Annotated[
        Optional[float],
        Field(
            description="The overall accuracy of the trained generator.\nThis is the average of the overall accuracy scores of all trained models.\n"
        ),
    ] = None
    usage: Optional[GeneratorUsage] = None
    tables: Annotated[
        Optional[List[SourceTable]], Field(description="The tables of this generator")
    ] = None
    synthetic_datasets: Annotated[
        Optional[List[BaseResource]],
        Field(
            alias="syntheticDatasets",
            description="The synthetic datasets that were created with this generator.",
        ),
    ] = None

    def add_table(self, **kwargs) -> "SourceTable":
        if self.client and hasattr(self.client, "add_table"):
            return self.client.add_table(generator_id=self.id, **kwargs)

    def add_table_by_upload(self, **kwargs) -> "SourceTable":
        if self.client and hasattr(self.client, "add_table_by_upload"):
            return self.client.add_table_by_upload(generator_id=self.id, **kwargs)

    def add_table_from_df_by_upload(self, **kwargs) -> "SourceTable":
        if self.client and hasattr(self.client, "add_table_from_df_by_upload"):
            return self.client.add_table_from_df_by_upload(
                generator_id=self.id, **kwargs
            )

    def get_table(self, **kwargs) -> "SourceTable":
        if self.client and hasattr(self.client, "get_table"):
            return self.client.get_table(generator_id=self.id, **kwargs)

    def update_table(self, **kwargs) -> "SourceTable":
        if self.client and hasattr(self.client, "update_table"):
            return self.client.update_table(generator_id=self.id, **kwargs)

    def delete_table(self, **kwargs) -> "SourceTable":
        if self.client and hasattr(self.client, "delete_table"):
            return self.client.delete_table(generator_id=self.id, **kwargs)

    # TRAINING STUBS

    def get_training_progress(self):
        pass

    def start_training(self):
        pass

    def stop_training(self):
        pass

    def cancel_training(self):
        pass

    def get_training_logs(self):
        pass


class JobProgress(CustomBaseModel):
    id: Optional[str] = None
    start_date: Annotated[
        Optional[str], Field(alias="startDate", example="2023‐09‐07T18:40:39Z")
    ] = None
    end_date: Annotated[
        Optional[str], Field(alias="endDate", example="2023‐09‐07T19:23:30Z")
    ] = None
    progress: Optional[ProgressValue] = None
    steps: Optional[List[ProgressStep]] = None


class SyntheticDataset(CustomBaseModel):
    id: Annotated[
        UUID, Field(description="The unique identifier of a synthetic dataset")
    ]
    generator: Optional[BaseResource] = None
    metadata: Metadata
    name: Annotated[str, Field(description="The name of a synthetic dataset")]
    description: Annotated[
        Optional[str], Field(description="The description of a synthetic dataset")
    ] = None
    generation_status: Annotated[ProgressStatus, Field(alias="generationStatus")]
    tables: Annotated[
        Optional[List[SyntheticTable]],
        Field(description="The tables of this synthetic dataset."),
    ] = None
    delivery: Optional[SyntheticDatasetDelivery] = None
    usage: Optional[SyntheticDatasetUsage] = None
